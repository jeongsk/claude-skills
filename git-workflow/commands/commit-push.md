---
description: "현재까지의 작업을 논리적 단위별로 나눠서 commit & push"
model: haiku
---

# 작업 단위별 commit & push 명령어

현재까지 작업한 내용을 논리적 단위별로 나눠서 commit하고, 최종적으로 원격 저장소에 push합니다.

## 개요

변경된 파일들을 분석하여 관련된 작업끼리 그룹화하고, 각 작업 단위별로 의미 있는 commit을 생성한 후 원격 저장소에 반영합니다.

## 수행 단계

### 1. 현재 변경사항 확인

먼저 현재 저장소의 상태를 파악합니다:
- `git status`로 현재 브랜치 및 staged/unstaged 변경사항 확인
- `git diff`로 각 파일의 변경 내용 상세 파악

### 2. 작업을 논리적 단위로 분류

변경사항을 분석하여 관련된 것끼리 그룹화합니다:
- 관련된 변경사항끼리 묶어서 분류
- 각 그룹이 하나의 완성된 기능/수정 단위가 되도록 구성
- 분류 예시:
  - 새로운 기능 추가
  - 버그 수정
  - 코드 리팩토링
  - 문서 수정
  - 스타일 변경
  - 테스트 추가

### 3. 각 단위별로 순차 commit

가장 핵심적인 변경부터 시작하여 각 작업 단위별로 commit을 생성합니다:

1. 해당 작업 단위의 파일들을 스테이징
   ```bash
   git add [관련 파일들]
   ```

2. 컨벤션에 맞는 commit 메시지 작성
   - 형식: `type(scope): 설명`
   - 타입 종류:
     - `feat`: 새로운 기능 추가
     - `fix`: 버그 수정
     - `refactor`: 코드 리팩토링
     - `docs`: 문서 수정
     - `style`: 코드 포맷팅, 세미콜론 누락 등
     - `test`: 테스트 코드 추가/수정
     - `chore`: 빌드 설정, 패키지 매니저 등
   - 설명은 현재형으로 작성 (예: "add" not "added")
   - 제목은 50자 이내로 작성

3. commit 실행
   ```bash
   git commit -m "type(scope): 설명"
   ```

### 4. commit 완료 확인

모든 commit이 완료된 후 결과를 확인합니다:
- `git log --oneline -10`으로 생성된 commit 이력 확인
- `git status`로 남은 변경사항 확인

### 5. 원격 저장소에 push

commit된 변경사항을 원격 저장소에 반영합니다:

1. 기본 push 실행
   ```bash
   git push origin <current-branch>
   ```

2. push 실패 시 대응
   - **업스트림 미설정**: 새 브랜치인 경우 upstream 설정과 함께 push
     ```bash
     git push -u origin <branch-name>
     ```
   - **충돌 발생**: 원격 브랜치의 변경사항을 먼저 pull하여 병합
   - **권한 문제**: 저장소 접근 권한 확인

3. push 결과 확인

## 주의사항

- **독립성**: 각 commit은 독립적으로 의미가 있어야 하며, 단독으로 리버트 가능해야 함
- **분리 원칙**: 관련 없는 변경사항은 반드시 별도 commit으로 분리
- **보안**: .env, credentials.json 등 민감한 파일은 절대 commit하지 않음
- **원자성**: 하나의 commit은 하나의 논리적 변경만 포함
- **push 전 확인**: 원격 브랜치와의 충돌 여부를 미리 확인

## 인수 처리

`$ARGUMENTS`가 제공되면 해당 메시지를 commit 메시지로 직접 사용합니다.